import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';

const App = () => {
  // App state
  const [showApp, setShowApp] = useState(false);
  const [activeTab, setActiveTab] = useState('wallet');
  
  // Wallet state
  const [wallet, setWallet] = useState(null);
  const [walletStep, setWalletStep] = useState('initial');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const [backupConfirmed, setBackupConfirmed] = useState(false);
  
  // Network and RPC state
  const [selectedNetwork, setSelectedNetwork] = useState('optimism');
  const [customRpc, setCustomRpc] = useState('');
  const [showRpcInput, setShowRpcInput] = useState(false);
  const [currentProvider, setCurrentProvider] = useState(null);
  
  // Blockchain connection state
  const [isConnectedToMetaMask, setIsConnectedToMetaMask] = useState(false);
  const [web3Provider, setWeb3Provider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [connectedAddress, setConnectedAddress] = useState(null);
  const [networkInfo, setNetworkInfo] = useState(null);
  const [isConnecting, setIsConnecting] = useState(false);
  
  // Minting state
  const [isMinting, setIsMinting] = useState(false);
  const [mintingProgress, setMintingProgress] = useState(0);
  const [mintingLogs, setMintingLogs] = useState([]);
  const [currentTransaction, setCurrentTransaction] = useState(null);
  const [isPaused, setIsPaused] = useState(false);
  const [shouldStopMinting, setShouldStopMinting] = useState(false);

  // Network configurations
  const NETWORKS = {
    optimism: {
      name: 'Optimism',
      chainId: 10,
      defaultRpc: 'https://mainnet.optimism.io',
      explorer: 'https://optimistic.etherscan.io',
      currency: 'ETH',
      contracts: {
        xenft: '0xAF18644083151cf57F914CCCc23c42A1892C218e'
      }
    },
    ethereum: {
      name: 'Ethereum',
      chainId: 1,
      defaultRpc: 'https://rpc.ankr.com/eth',
      explorer: 'https://etherscan.io',
      currency: 'ETH',
      contracts: {
        xenft: '0x06450dEe7FD2Fb8E39061434BAbCFC05599a6Fb8'
      }
    },
    base: {
      name: 'Base',
      chainId: 8453,
      defaultRpc: 'https://mainnet.base.org',
      explorer: 'https://basescan.org',
      currency: 'ETH',
      contracts: {
        xenft: '0x379002701BF6f2862e3dFdd1f96d3C5E1BF450B6'
      }
    }
  };

  // XENFT Contract ABI
  const XENFT_ABI = [
    'function bulkClaimRank(uint256 count, uint256 term) returns (uint256)'
  ];

  // Power Group Calculation
  const POWER_GROUP_SIZE = 7500;
  
  const calculatePowerGroup = (vmu, term) => {
    return Math.floor((vmu * term) / POWER_GROUP_SIZE);
  };

  const calculateTermForPowerGroup = (vmu, powerGroup) => {
    return Math.ceil((powerGroup * POWER_GROUP_SIZE) / vmu);
  };

  // Get current RPC URL
  const getCurrentRpcUrl = () => {
    if (customRpc && customRpc.trim()) {
      return customRpc.trim();
    }
    return NETWORKS[selectedNetwork].defaultRpc;
  };

  // Get current contract address
  const getCurrentContractAddress = () => {
    return NETWORKS[selectedNetwork].contracts.xenft;
  };

  // Initialize provider for current network
  const initializeProvider = async () => {
    try {
      const rpcUrl = getCurrentRpcUrl();
      const provider = new ethers.JsonRpcProvider(rpcUrl);
      
      // Test the connection
      await provider.getNetwork();
      
      setCurrentProvider(provider);
      return provider;
    } catch (err) {
      console.error('Failed to initialize provider:', err);
      setError(`Failed to connect to ${selectedNetwork} RPC: ${err.message}`);
      return null;
    }
  };

  // Update provider when network or RPC changes
  useEffect(() => {
    initializeProvider();
  }, [selectedNetwork, customRpc]);

  // Initialize on app load
  useEffect(() => {
    checkExistingConnection();
    setupEventListeners();
  }, []);

  // Check for existing wallet and blockchain connection
  const checkExistingConnection = async () => {
    // Check for stored wallet
    const savedAddress = sessionStorage.getItem('mintxen_wallet_address');
    const savedKey = sessionStorage.getItem('mintxen_wallet_key');
    const isVerified = localStorage.getItem('mintxen_wallet_verified');
    
    if (savedAddress && savedKey && isVerified) {
      try {
        const restoredWallet = new ethers.Wallet(savedKey);
        setWallet({
          address: restoredWallet.address,
          privateKey: restoredWallet.privateKey,
          mnemonic: null
        });
        setWalletStep('complete');
        setActiveTab('rainbow');
      } catch (err) {
        console.error('Failed to restore wallet:', err);
        clearStoredWallet();
      }
    }

    // Check for existing MetaMask connection
    if (window.ethereum) {
      try {
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts.length > 0) {
          await connectToBlockchain(accounts[0]);
        }
      } catch (err) {
        console.error('Failed to check existing connection:', err);
      }
    }
  };

  // Setup MetaMask event listeners
  const setupEventListeners = () => {
    if (window.ethereum) {
      window.ethereum.on('accountsChanged', handleAccountsChanged);
      window.ethereum.on('chainChanged', handleChainChanged);
      window.ethereum.on('disconnect', handleDisconnect);
    }
  };

  // Handle account changes
  const handleAccountsChanged = (accounts) => {
    if (accounts.length === 0) {
      disconnectBlockchain();
    } else {
      connectToBlockchain(accounts[0]);
    }
  };

  // Handle network changes
  const handleChainChanged = () => {
    window.location.reload();
  };

  // Handle disconnect
  const handleDisconnect = () => {
    disconnectBlockchain();
  };

  // Connect to blockchain
  const connectToBlockchain = async (address = null) => {
    setIsConnecting(true);
    setError('');
    
    try {
      if (!window.ethereum) {
        throw new Error('MetaMask is not installed. Please install MetaMask.');
      }

      let accounts;
      if (address) {
        accounts = [address];
      } else {
        accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      }

      if (accounts.length === 0) {
        throw new Error('No accounts found. Please unlock your wallet.');
      }

      const provider = new ethers.BrowserProvider(window.ethereum);
      const walletSigner = await provider.getSigner();
      const network = await provider.getNetwork();

      setWeb3Provider(provider);
      setSigner(walletSigner);
      setConnectedAddress(accounts[0]);
      setIsConnectedToMetaMask(true);
      setNetworkInfo({
        name: network.name,
        chainId: network.chainId.toString()
      });

      localStorage.setItem('mintxen_connected', 'true');
      localStorage.setItem('mintxen_connected_address', accounts[0]);

    } catch (err) {
      setError(`Failed to connect: ${err.message}`);
      disconnectBlockchain();
    } finally {
      setIsConnecting(false);
    }
  };

  // Disconnect from blockchain
  const disconnectBlockchain = () => {
    setWeb3Provider(null);
    setSigner(null);
    setConnectedAddress(null);
    setIsConnectedToMetaMask(false);
    setNetworkInfo(null);
    
    localStorage.removeItem('mintxen_connected');
    localStorage.removeItem('mintxen_connected_address');
  };

  // Clear stored wallet
  const clearStoredWallet = () => {
    sessionStorage.removeItem('mintxen_wallet_address');
    sessionStorage.removeItem('mintxen_wallet_key');
    localStorage.removeItem('mintxen_wallet_verified');
    setWallet(null);
    setWalletStep('initial');
    setActiveTab('wallet');
  };

  // Wallet Management Functions
  const generateWallet = async () => {
    setLoading(true);
    setError('');
    
    try {
      const newWallet = ethers.Wallet.createRandom();
      
      const walletData = {
        address: newWallet.address,
        privateKey: newWallet.privateKey,
        mnemonic: newWallet.mnemonic?.phrase || null
      };
      
      setWallet(walletData);
      setWalletStep('backup');
      
      sessionStorage.setItem('mintxen_wallet_address', walletData.address);
      sessionStorage.setItem('mintxen_wallet_key', walletData.privateKey);
      
    } catch (err) {
      setError(`Failed to generate wallet: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  const importWallet = async () => {
    setError('');
    const privateKey = prompt('Enter your private key (0x...):');
    
    if (!privateKey) return;
    
    try {
      setLoading(true);
      const importedWallet = new ethers.Wallet(privateKey);
      
      const walletData = {
        address: importedWallet.address,
        privateKey: importedWallet.privateKey,
        mnemonic: null
      };
      
      setWallet(walletData);
      setWalletStep('backup');
      
      sessionStorage.setItem('mintxen_wallet_address', walletData.address);
      sessionStorage.setItem('mintxen_wallet_key', walletData.privateKey);
      
    } catch (err) {
      setError(`Invalid private key: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  const copyToClipboard = async (text, type) => {
    try {
      await navigator.clipboard.writeText(text);
      alert(`${type} copied to clipboard!`);
    } catch (err) {
      setError(`Failed to copy ${type}: ${err.message}`);
    }
  };

  const downloadBackup = () => {
    if (!wallet) return;
    
    const backupData = {
      address: wallet.address,
      privateKey: wallet.privateKey,
      mnemonic: wallet.mnemonic,
      timestamp: new Date().toISOString(),
      warning: "KEEP THIS FILE SECURE! Anyone with this information can access your funds."
    };
    
    const dataStr = JSON.stringify(backupData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `mintxen-wallet-${wallet.address.slice(0, 8)}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const completeWalletSetup = () => {
    if (!backupConfirmed) {
      setError('Please confirm you have backed up your private key before proceeding.');
      return;
    }
    setWalletStep('complete');
    localStorage.setItem('mintxen_wallet_verified', 'true');
    setActiveTab('rainbow');
  };

  // Stop minting function
  const stopMinting = () => {
    setShouldStopMinting(true);
    setIsPaused(false);
    setIsMinting(false);
    setCurrentTransaction(null);
  };

  // Pause/Resume functions
  const pauseMinting = () => {
    setIsPaused(true);
  };

  const resumeMinting = () => {
    setIsPaused(false);
  };

  // Automated XENFT Minting Functions - FIXED VERSION
  const startRainbowMinting = async (config = {}) => {
    if (!wallet || !wallet.privateKey) {
      setError('No wallet found. Please create or import a wallet first.');
      return;
    }

    if (!currentProvider) {
      setError('Provider not available. Please check your network connection.');
      return;
    }

    setIsMinting(true);
    setMintingProgress(0);
    setMintingLogs([]);
    setShouldStopMinting(false);
    setIsPaused(false);

    const addLog = (message, type = 'info') => {
      const log = {
        timestamp: new Date().toLocaleTimeString(),
        message,
        type
      };
      setMintingLogs(prev => [...prev, log]);
    };

    try {
      addLog('üåà Starting Rainbow Mode minting...', 'info');
      addLog(`üåê Network: ${NETWORKS[selectedNetwork].name}`, 'info');
      addLog(`üîó RPC: ${getCurrentRpcUrl()}`, 'info');
      
      const vmu = config.vmu || 128;
      const gasPrice = config.gasPrice || '0.00003';
      const delay = config.delay || 60000;
      
      // Use the current provider (default or custom RPC)
      const automatedSigner = new ethers.Wallet(wallet.privateKey, currentProvider);
      
      addLog(`üîë Using wallet: ${automatedSigner.address}`, 'info');
      
      // Calculate power groups
      const powerGroups = [];
      for (let pg = 7; pg >= 0; pg--) {
        const term = Math.max(1, calculateTermForPowerGroup(vmu, pg));
        const actualPowerGroup = calculatePowerGroup(vmu, term);
        powerGroups.push({
          name: `Power Group ${pg}`,
          powerGroup: pg,
          term: term,
          actualPowerGroup: actualPowerGroup
        });
      }

      if (config.reverse) {
        powerGroups.reverse();
      }

      addLog(`Configuration: ${vmu} VMUs, ${gasPrice} gwei, ${powerGroups.length} power groups`, 'info');
      
      // Create contract instance
      const contractAddress = getCurrentContractAddress();
      const contract = new ethers.Contract(contractAddress, XENFT_ABI, automatedSigner);
      
      for (let i = 0; i < powerGroups.length; i++) {
        // Check if we should stop
        if (shouldStopMinting) {
          addLog('üõë Minting stopped by user', 'warning');
          break;
        }

        const group = powerGroups[i];
        
        setCurrentTransaction({
          index: i + 1,
          total: powerGroups.length,
          group: group.name,
          powerGroup: group.powerGroup,
          term: group.term,
          vmu: vmu
        });
        
        addLog(`[${i + 1}/${powerGroups.length}] Minting ${group.name} (${group.term} days, ${vmu} VMUs)...`, 'info');
        
        try {
          // Wait for pause to be lifted
          while (isPaused && !shouldStopMinting) {
            addLog('‚è∏Ô∏è Minting paused...', 'warning');
            await new Promise(resolve => setTimeout(resolve, 1000));
          }

          // Check again if we should stop after pause
          if (shouldStopMinting) {
            addLog('üõë Minting stopped by user', 'warning');
            break;
          }
          
          // Get current nonce for the wallet
          const nonce = await currentProvider.getTransactionCount(automatedSigner.address, 'pending');
          
          addLog(`üìä Current nonce: ${nonce}`, 'info');
          addLog(`‚õΩ Estimating gas for ${group.term} day term...`, 'info');
          
          // Estimate gas
          const estimatedGas = await contract.bulkClaimRank.estimateGas(vmu, group.term);
          const gasLimit = estimatedGas * BigInt(120) / BigInt(100); // 20% buffer
          
          addLog(`‚õΩ Gas limit: ${Number(gasLimit).toLocaleString()} units`, 'info');
          
          // Prepare transaction with automated signing
          const txParams = {
            type: 2,
            nonce: nonce,
            maxFeePerGas: ethers.parseUnits(gasPrice, 'gwei'),
            maxPriorityFeePerGas: ethers.parseUnits(gasPrice, 'gwei'),
            gasLimit: gasLimit
          };
          
          addLog(`üöÄ Submitting transaction for ${group.name} (automated)...`, 'info');
          
          // Send transaction automatically
          const tx = await contract.bulkClaimRank(vmu, group.term, txParams);
          
          addLog(`‚úÖ Transaction submitted: ${tx.hash}`, 'info');
          addLog(`üîó View on explorer: ${NETWORKS[selectedNetwork].explorer}/tx/${tx.hash}`, 'info');
          
          addLog('‚è≥ Waiting for confirmation...', 'info');
          const receipt = await tx.wait();
          
          // Calculate costs
          const gasUsed = BigInt(receipt.gasUsed?.toString() || '0');
          const effectiveGasPrice = BigInt(receipt.effectiveGasPrice?.toString() || '0');
          const txEthCost = parseFloat(ethers.formatEther(gasUsed * effectiveGasPrice));
          
          const ethPrice = 2500; // Simplified for demo
          const txUsdCost = txEthCost * ethPrice;
          
          addLog(`üéâ ${group.name} minted successfully! Block: ${receipt.blockNumber}`, 'success');
          addLog(`üí∞ Cost: $${txUsdCost.toFixed(4)} (${txEthCost.toFixed(8)} ${NETWORKS[selectedNetwork].currency})`, 'info');
          addLog(`üéØ Effective power group: ${group.actualPowerGroup} (${vmu} √ó ${group.term} √∑ 7500 = ${((vmu * group.term) / 7500).toFixed(2)})`, 'info');
          
          setMintingProgress(((i + 1) / powerGroups.length) * 100);
          
          if (i < powerGroups.length - 1 && !shouldStopMinting) {
            addLog(`‚è±Ô∏è Waiting ${delay / 1000} seconds before next transaction...`, 'info');
            
            // Break delay into smaller chunks to check for stop signal
            const delayChunks = Math.ceil(delay / 1000); // 1 second chunks
            for (let chunk = 0; chunk < delayChunks; chunk++) {
              if (shouldStopMinting) {
                addLog('üõë Minting stopped during delay', 'warning');
                break;
              }
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          }
          
        } catch (err) {
          addLog(`‚ùå Failed to mint ${group.name}: ${err.message}`, 'error');
          
          // Continue with next power group even if one fails
          if (err.message.includes('insufficient funds')) {
            addLog(`üí∏ Insufficient funds detected. Stopping minting process.`, 'error');
            break;
          }
        }
      }
      
      if (!shouldStopMinting) {
        addLog('üéä Rainbow minting completed!', 'success');
        addLog('üîç Check your wallet for new XENFTs!', 'info');
      }
      
    } catch (err) {
      addLog(`‚ùå Rainbow minting failed: ${err.message}`, 'error');
    } finally {
      setIsMinting(false);
      setCurrentTransaction(null);
      setShouldStopMinting(false);
      setIsPaused(false);
    }
  };

  const startLadderMinting = async (config = {}) => {
    if (!wallet || !wallet.privateKey) {
      setError('No wallet found. Please create or import a wallet first.');
      return;
    }

    if (!currentProvider) {
      setError('Provider not available. Please check your network connection.');
      return;
    }

    setIsMinting(true);
    setMintingProgress(0);
    setMintingLogs([]);
    setShouldStopMinting(false);
    setIsPaused(false);

    const addLog = (message, type = 'info') => {
      const log = {
        timestamp: new Date().toLocaleTimeString(),
        message,
        type
      };
      setMintingLogs(prev => [...prev, log]);
    };

    try {
      addLog('üìä Starting Ladder Mode minting...', 'info');
      addLog(`üåê Network: ${NETWORKS[selectedNetwork].name}`, 'info');
      addLog(`üîó RPC: ${getCurrentRpcUrl()}`, 'info');
      
      const vmu = config.vmu || 128;
      const gasPrice = config.gasPrice || '0.00003';
      const delay = config.delay || 60000;
      const startTerm = config.startTerm || 100;
      const endTerm = config.endTerm || 250;
      const batches = config.batches || 1;
      
      const totalTerms = endTerm - startTerm + 1;
      const totalTransactions = totalTerms * batches;
      
      // Use the current provider (default or custom RPC)
      const automatedSigner = new ethers.Wallet(wallet.privateKey, currentProvider);
      
      addLog(`üîë Using wallet: ${automatedSigner.address}`, 'info');
      addLog(`üìà Configuration: ${startTerm}-${endTerm} days, ${vmu} VMUs, ${batches} batches per term`, 'info');
      addLog(`üéØ Total transactions: ${totalTransactions}`, 'info');
      
      const contractAddress = getCurrentContractAddress();
      const contract = new ethers.Contract(contractAddress, XENFT_ABI, automatedSigner);
      
      let txCount = 0;
      
      for (let term = startTerm; term <= endTerm; term++) {
        for (let batch = 1; batch <= batches; batch++) {
          // Check if we should stop
          if (shouldStopMinting) {
            addLog('üõë Minting stopped by user', 'warning');
            break;
          }

          txCount++;
          const powerGroup = calculatePowerGroup(vmu, term);
          
          setCurrentTransaction({
            index: txCount,
            total: totalTransactions,
            term: term,
            batch: batch,
            batches: batches,
            vmu: vmu,
            powerGroup: powerGroup
          });
          
          addLog(`[${txCount}/${totalTransactions}] Minting ${term}-day XENFT (Batch ${batch}/${batches}, PG: ${powerGroup})...`, 'info');
          
          try {
            // Wait for pause to be lifted
            while (isPaused && !shouldStopMinting) {
              addLog('‚è∏Ô∏è Minting paused...', 'warning');
              await new Promise(resolve => setTimeout(resolve, 1000));
            }

            // Check again if we should stop after pause
            if (shouldStopMinting) {
              addLog('üõë Minting stopped by user', 'warning');
              break;
            }

            const nonce = await currentProvider.getTransactionCount(automatedSigner.address, 'pending');
            
            addLog(`üìä Nonce: ${nonce} | Estimating gas...`, 'info');
            
            const estimatedGas = await contract.bulkClaimRank.estimateGas(vmu, term);
            const gasLimit = estimatedGas * BigInt(120) / BigInt(100);
            
            const txParams = {
              type: 2,
              nonce: nonce,
              maxFeePerGas: ethers.parseUnits(gasPrice, 'gwei'),
              maxPriorityFeePerGas: ethers.parseUnits(gasPrice, 'gwei'),
              gasLimit: gasLimit
            };
            
            addLog(`üöÄ Submitting ${term}-day transaction (automated)...`, 'info');
            const tx = await contract.bulkClaimRank(vmu, term, txParams);
            addLog(`‚úÖ Transaction submitted: ${tx.hash}`, 'info');
            
            addLog('‚è≥ Waiting for confirmation...', 'info');
            const receipt = await tx.wait();
            
            const gasUsed = BigInt(receipt.gasUsed?.toString() || '0');
            const effectiveGasPrice = BigInt(receipt.effectiveGasPrice?.toString() || '0');
            const txEthCost = parseFloat(ethers.formatEther(gasUsed * effectiveGasPrice));
            
            const ethPrice = 2500;
            const txUsdCost = txEthCost * ethPrice;
            
            addLog(`üéâ ${term}-day XENFT minted! Block: ${receipt.blockNumber}`, 'success');
            addLog(`üí∞ Cost: $${txUsdCost.toFixed(4)} (${txEthCost.toFixed(8)} ${NETWORKS[selectedNetwork].currency})`, 'info');
            
            setMintingProgress((txCount / totalTransactions) * 100);
            
            if (txCount < totalTransactions && !shouldStopMinting) {
              addLog(`‚è±Ô∏è Waiting ${delay / 1000}s before next transaction...`, 'info');
              
              // Break delay into smaller chunks to check for stop signal
              const delayChunks = Math.ceil(delay / 1000); // 1 second chunks
              for (let chunk = 0; chunk < delayChunks; chunk++) {
                if (shouldStopMinting) {
                  addLog('üõë Minting stopped during delay', 'warning');
                  break;
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
              }
            }
            
          } catch (err) {
            addLog(`‚ùå Failed to mint ${term}-day XENFT (batch ${batch}): ${err.message}`, 'error');
            
            if (err.message.includes('insufficient funds')) {
              addLog(`üí∏ Insufficient funds. Stopping minting process.`, 'error');
              return;
            }
          }
        }
        
        // Check if we should stop after each term
        if (shouldStopMinting) {
          break;
        }
      }
      
      if (!shouldStopMinting) {
        addLog('üéä Ladder minting completed!', 'success');
        addLog('üîç Check your wallet for new XENFTs!', 'info');
      }
      
    } catch (err) {
      addLog(`‚ùå Ladder minting failed: ${err.message}`, 'error');
    } finally {
      setIsMinting(false);
      setCurrentTransaction(null);
      setShouldStopMinting(false);
      setIsPaused(false);
    }
  };

  // Network Selector Component
  const NetworkSelector = () => (
    <div className="network-selector">
      <select 
        value={selectedNetwork} 
        onChange={(e) => setSelectedNetwork(e.target.value)}
        className="network-select"
      >
        {Object.entries(NETWORKS).map(([key, network]) => (
          <option key={key} value={key}>
            {network.name}
          </option>
        ))}
      </select>
      
      <button 
        onClick={() => setShowRpcInput(!showRpcInput)}
        className="rpc-toggle-btn"
        title="Custom RPC"
      >
        üîß
      </button>
      
      {showRpcInput && (
        <div className="rpc-input-container">
          <input
            type="text"
            placeholder={`Default: ${NETWORKS[selectedNetwork].defaultRpc}`}
            value={customRpc}
            onChange={(e) => setCustomRpc(e.target.value)}
            className="rpc-input"
          />
          <button 
            onClick={() => {
              setCustomRpc('');
              setShowRpcInput(false);
            }}
            className="rpc-clear-btn"
          >
            ‚úï
          </button>
        </div>
      )}
    </div>
  );

  // FIXED Input Component - Only fixes the input field issues, keeps original styling
  const NumberInput = ({ label, value, onChange, placeholder, min, max, step = 1, hint }) => {
    const [inputValue, setInputValue] = useState('');

    // Only update input when value changes and field is not focused
    useEffect(() => {
      setInputValue(value?.toString() || '');
    }, [value]);

    const handleChange = (e) => {
      const newValue = e.target.value;
      setInputValue(newValue);
      
      // Convert to number or pass empty string
      if (newValue === '') {
        onChange('');
      } else {
        const numValue = parseFloat(newValue);
        if (!isNaN(numValue)) {
          onChange(numValue);
        }
      }
    };

    return (
      <div className="config-item">
        <label className="config-label">{label}</label>
        <input
          type="number"
          min={min}
          max={max}
          step={step}
          value={inputValue}
          onChange={handleChange}
          placeholder={placeholder}
          className="config-input"
        />
        {hint && <span className="hint">{hint}</span>}
      </div>
    );
  };

  // Tab components
  const WalletTab = () => (
    <div className="tab-content">
      {walletStep === 'initial' && (
        <div className="wallet-setup">
          <div className="wallet-header">
            <div className="wallet-icon">üîë</div>
            <h3>Create or Import Wallet</h3>
            <p>To start minting XENFTs, you need a wallet. You can generate a new one or import an existing private key.</p>
          </div>

          <div className="security-notice">
            <div className="notice-icon">üõ°Ô∏è</div>
            <div>
              <h4>Security Notice</h4>
              <p>Your private key will only be stored in this browser session and will be deleted when you close the browser. Always back up your private key securely - it controls access to your assets.</p>
            </div>
          </div>

          <div className="wallet-actions">
            <button onClick={generateWallet} disabled={loading} className="btn-primary">
              {loading ? '‚è≥ Generating...' : '‚ö° Generate New Wallet'}
            </button>
            
            <div className="divider">
              <span>Or</span>
            </div>

            <button onClick={importWallet} disabled={loading} className="btn-secondary">
              üîê Import Private Key
            </button>
          </div>
        </div>
      )}

      {walletStep === 'backup' && wallet && (
        <div className="wallet-backup">
          <div className="wallet-header">
            <div className="wallet-icon">üîí</div>
            <h3>Backup Your Wallet</h3>
            <p>Save your private key securely - you'll need it to access your funds</p>
          </div>

          <div className="critical-warning">
            <div className="notice-icon">‚ö†Ô∏è</div>
            <div>
              <h4>CRITICAL: Backup Required</h4>
              <p>Your private key will be deleted when you close this browser. Without backup, you'll lose access to your funds permanently!</p>
            </div>
          </div>

          <div className="wallet-details">
            <div className="wallet-field">
              <label>Wallet Address:</label>
              <div className="address-display">
                <span>{wallet.address}</span>
                <button onClick={() => copyToClipboard(wallet.address, 'Address')} className="copy-btn">üìã</button>
              </div>
            </div>
            
            <div className="wallet-field">
              <label>Private Key:</label>
              <div className="address-display">
                <span>{wallet.privateKey}</span>
                <button onClick={() => copyToClipboard(wallet.privateKey, 'Private Key')} className="copy-btn">üìã</button>
              </div>
            </div>
          </div>

          <div className="backup-options">
            <h4>üîë Backup Options</h4>
            <button onClick={downloadBackup} className="btn-secondary">
              üíæ Download Backup File (.json)
            </button>
            <div className="backup-checklist">
              <p><strong>Manual Backup Checklist:</strong></p>
              <ul>
                <li>‚Ä¢ Copy private key to a password manager</li>
                <li>‚Ä¢ Write it down on paper and store securely</li>
                <li>‚Ä¢ Never share this key with anyone</li>
                <li>‚Ä¢ Import this key into MetaMask</li>
              </ul>
            </div>
          </div>

          <div className="confirmation">
            <label className="checkbox-label">
              <input
                type="checkbox"
                checked={backupConfirmed}
                onChange={(e) => setBackupConfirmed(e.target.checked)}
              />
              I confirm I have securely backed up my private key
            </label>
            
            <button 
              onClick={completeWalletSetup}
              disabled={!backupConfirmed}
              className="btn-primary"
            >
              ‚úÖ Complete Setup
            </button>
          </div>
        </div>
      )}

      {walletStep === 'complete' && (
        <div className="wallet-complete">
          <div className="success-icon">‚úÖ</div>
          <h3>Wallet Ready!</h3>
          <p>Your wallet has been set up successfully. You can now start minting XENFTs.</p>
          
          <div className="wallet-info">
            <p><strong>Active Wallet:</strong></p>
            <div className="address-display">
              <span>{wallet?.address}</span>
            </div>
          </div>

          <div className="network-info">
            <h4>Network Information:</h4>
            <div className="info-grid">
              <div className="info-item">
                <span className="info-label">Selected Network:</span>
                <span className="info-value">{NETWORKS[selectedNetwork].name}</span>
              </div>
              <div className="info-item">
                <span className="info-label">RPC Provider:</span>
                <span className="info-value">{customRpc || 'Default'}</span>
              </div>
              <div className="info-item">
                <span className="info-label">Contract:</span>
                <span className="info-value">{getCurrentContractAddress()}</span>
              </div>
            </div>
          </div>

          <div className="next-steps">
            <h4>Next Steps:</h4>
            <ol>
              <li>Select your preferred network in the header</li>
              <li>Optionally set a custom RPC for better performance</li>
              <li>Ensure your wallet has {NETWORKS[selectedNetwork].currency} for gas fees</li>
              <li>Choose your minting strategy (Rainbow or Ladder mode)</li>
              <li>Start your XENFT minting journey!</li>
            </ol>
          </div>
        </div>
      )}

      {error && (
        <div className="error-message">
          <span className="error-icon">‚ö†Ô∏è</span>
          <p>{error}</p>
        </div>
      )}
    </div>
  );

  const RainbowTab = () => {
    const [config, setConfig] = useState({
      vmu: 128,
      gasPrice: '0.00003',
      delay: 60000,
      reverse: false
    });

    const handleConfigChange = (field, value) => {
      setConfig(prev => ({ ...prev, [field]: value }));
    };

    const handleStartMinting = () => {
      startRainbowMinting(config);
    };

    return (
      <div className="tab-content">
        <div className="mode-header">
          <div className="mode-icon">üåà</div>
          <h3>Rainbow Mode</h3>
          <p>Create a rainbow of Common Class XENFTs with different power groups (0-7)</p>
        </div>

        <div className="config-section">
          <h4>‚öôÔ∏è Configuration</h4>
          
          <div className="config-grid">
            <NumberInput
              label="VMUs per Transaction"
              value={config.vmu}
              onChange={(value) => handleConfigChange('vmu', value || 128)}
              placeholder="128"
              min={1}
              max={1000}
              hint="Higher VMUs = Higher power groups"
            />
            
            <div className="config-item">
              <label className="config-label">Gas Price (gwei)</label>
              <input 
                type="text" 
                value={config.gasPrice}
                onChange={(e) => handleConfigChange('gasPrice', e.target.value)}
                placeholder="0.00003"
                className="config-input"
              />
              <span className="hint">Lower = cheaper, slower confirmation</span>
            </div>
            
            <NumberInput
              label="Delay Between Transactions (seconds)"
              value={config.delay / 1000}
              onChange={(value) => handleConfigChange('delay', (value || 60) * 1000)}
              placeholder="60"
              min={5}
              max={3600}
              hint="Time between each mint"
            />
          </div>
        </div>

        <div className="power-groups-section">
          <h4>üé® Power Groups Preview</h4>
          <div className="power-groups-grid">
            {[
              { name: "PG 7", color: "#8b5cf6", days: Math.max(1, calculateTermForPowerGroup(config.vmu, 7)), emoji: "üíú" },
              { name: "PG 6", color: "#3b82f6", days: Math.max(1, calculateTermForPowerGroup(config.vmu, 6)), emoji: "üíô" },
              { name: "PG 5", color: "#06b6d4", days: Math.max(1, calculateTermForPowerGroup(config.vmu, 5)), emoji: "ü©µ" },
              { name: "PG 4", color: "#10b981", days: Math.max(1, calculateTermForPowerGroup(config.vmu, 4)), emoji: "üíö" },
              { name: "PG 3", color: "#eab308", days: Math.max(1, calculateTermForPowerGroup(config.vmu, 3)), emoji: "üíõ" },
              { name: "PG 2", color: "#ef4444", days: Math.max(1, calculateTermForPowerGroup(config.vmu, 2)), emoji: "‚ù§Ô∏è" },
              { name: "PG 1", color: "#6b7280", days: Math.max(1, calculateTermForPowerGroup(config.vmu, 1)), emoji: "ü§ç" },
              { name: "PG 0", color: "#9ca3af", days: Math.max(1, calculateTermForPowerGroup(config.vmu, 0)), emoji: "üñ§" }
            ].map((group, index) => (
              <div key={group.name} className="power-group-card">
                <div className="power-group-icon">
                  <span>{group.emoji}</span>
                </div>
                <div className="power-group-info">
                  <h5>{group.name}</h5>
                  <p>{group.days} days</p>
                  <p>{config.vmu} VMUs</p>
                </div>
                <div className="power-group-indicator" style={{ backgroundColor: group.color }}></div>
              </div>
            ))}
          </div>
        </div>

        <div className="options-section">
          <h4>üîß Advanced Options</h4>
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={config.reverse}
              onChange={(e) => handleConfigChange('reverse', e.target.checked)}
            />
            üîÑ Reverse order (mint from PG 0 to 7)
          </label>
        </div>

        {!wallet && (
          <div className="warning-message">
            <span className="warning-icon">‚ö†Ô∏è</span>
            <div>
              <h4>No Wallet Found</h4>
              <p>Please create or import a wallet to enable automated minting.</p>
            </div>
          </div>
        )}

        {!currentProvider && (
          <div className="warning-message">
            <span className="warning-icon">‚ö†Ô∏è</span>
            <div>
              <h4>Provider Not Available</h4>
              <p>Please check your network connection and RPC settings.</p>
            </div>
          </div>
        )}

        <div className="status-section success">
          <div className="status-icon">ü§ñ</div>
          <div>
            <h4>Automated Minting {wallet && currentProvider ? 'Ready' : 'Pending Setup'}</h4>
            <ul>
              <li>‚úÖ No MetaMask popups - Runs in background</li>
              <li>‚úÖ No user interaction - Set and forget</li>
              <li>{currentProvider ? '‚úÖ' : '‚è≥'} Uses {customRpc ? 'custom' : 'default'} RPC</li>
              <li>‚úÖ Automatic gas estimation & cost tracking</li>
              <li>üéØ Network: {NETWORKS[selectedNetwork].name}</li>
              <li>üéØ Contract: {getCurrentContractAddress()}</li>
            </ul>
          </div>
        </div>

        <div className="launch-section">
          <button 
            onClick={handleStartMinting}
            disabled={!wallet || !currentProvider || isMinting}
            className={`launch-button ${(!wallet || !currentProvider || isMinting) ? 'disabled' : ''}`}
          >
            <span className="button-icon">
              {isMinting ? 'ü§ñ' : 'üåà'}
            </span>
            <span className="button-text">
              {isMinting ? 'Automated Minting in Progress...' : 'Start Automated Rainbow Minting'}
            </span>
          </button>

          {!wallet && (
            <div className="launch-hint">
              <p>Need a wallet? Go to the Wallet tab to create or import one.</p>
            </div>
          )}
          
          {!currentProvider && (
            <div className="launch-hint">
              <p>Provider not available. Check your network connection.</p>
            </div>
          )}
        </div>

        {/* Minting Progress */}
        {(isMinting || mintingLogs.length > 0) && (
          <MintingProgress 
            isMinting={isMinting}
            progress={mintingProgress}
            currentTransaction={currentTransaction}
            logs={mintingLogs}
            onStop={stopMinting}
            onPause={pauseMinting}
            onResume={resumeMinting}
            isPaused={isPaused}
          />
        )}
      </div>
    );
  };

  const LadderTab = () => {
    const [config, setConfig] = useState({
      vmu: 128,
      gasPrice: '0.00003',
      delay: 60000,
      startTerm: 100,
      endTerm: 250,
      batches: 1
    });

    const handleConfigChange = (field, value) => {
      setConfig(prev => ({ ...prev, [field]: value }));
    };

    const handleStartMinting = () => {
      startLadderMinting(config);
    };

    const totalTerms = Math.max(0, config.endTerm - config.startTerm + 1);
    const totalTransactions = totalTerms * config.batches;
    const estimatedHours = (totalTransactions * (config.delay / 1000)) / 3600;

    return (
      <div className="tab-content">
        <div className="mode-header">
          <div className="mode-icon">üìä</div>
          <h3>Ladder Mode</h3>
          <p>Create custom laddered XENFT terms with precise control over ranges and batching</p>
        </div>

        <div className="config-section">
          <h4>‚öôÔ∏è Configuration</h4>
          
          <div className="config-grid">
            <NumberInput
              label="Start Term (days)"
              value={config.startTerm}
              onChange={(value) => handleConfigChange('startTerm', value)}
              placeholder="100"
              min={1}
              max={666}
              hint="Starting day term for ladder"
            />
            
            <NumberInput
              label="End Term (days)"
              value={config.endTerm}
              onChange={(value) => handleConfigChange('endTerm', value)}
              placeholder="250"
              min={1}
              max={666}
              hint="Ending day term for ladder"
            />
            
            <NumberInput
              label="Batches per Term"
              value={config.batches}
              onChange={(value) => handleConfigChange('batches', value || 1)}
              placeholder="1"
              min={1}
              max={10}
              hint="Number of XENFTs per term"
            />
            
            <NumberInput
              label="VMUs per Transaction"
              value={config.vmu}
              onChange={(value) => handleConfigChange('vmu', value)}
              placeholder="128"
              min={1}
              max={500}
              hint="Higher VMUs = Higher power groups"
            />
            
            <div className="config-item">
              <label className="config-label">Gas Price (gwei)</label>
              <input 
                type="text" 
                value={config.gasPrice}
                onChange={(e) => handleConfigChange('gasPrice', e.target.value)}
                placeholder="0.00004"
                className="config-input"
              />
              <span className="hint">Lower = cheaper, slower confirmation</span>
            </div>
            
            <NumberInput
              label="Delay Between Transactions (seconds)"
              value={config.delay / 1000}
              onChange={(value) => handleConfigChange('delay', value ? value * 1000 : '')}
              placeholder="60"
              min={5}
              max={3600}
              hint="Time between each mint"
            />
          </div>
        </div>

        <div className="summary-section">
          <h4>üìà Ladder Summary</h4>
          <div className="summary-grid">
            <div className="summary-card">
              <div className="summary-icon">üìä</div>
              <div>
                <h5>Total Terms</h5>
                <p className="summary-value">{totalTerms}</p>
                <p className="summary-detail">{config.startTerm} to {config.endTerm} days</p>
              </div>
            </div>
            
            <div className="summary-card">
              <div className="summary-icon">‚ö°</div>
              <div>
                <h5>Transactions</h5>
                <p className="summary-value">{totalTransactions}</p>
                <p className="summary-detail">{config.batches} batches per term</p>
              </div>
            </div>
            
            <div className="summary-card">
              <div className="summary-icon">‚è±Ô∏è</div>
              <div>
                <h5>Duration</h5>
                <p className="summary-value">{estimatedHours.toFixed(1)}h</p>
                <p className="summary-detail">Estimated completion time</p>
              </div>
            </div>
            
            <div className="summary-card">
              <div className="summary-icon">üéØ</div>
              <div>
                <h5>Total VMUs</h5>
                <p className="summary-value">{(totalTransactions * config.vmu).toLocaleString()}</p>
                <p className="summary-detail">Power groups {calculatePowerGroup(config.vmu, config.startTerm)} to {calculatePowerGroup(config.vmu, config.endTerm)}</p>
              </div>
            </div>
          </div>
        </div>

        {!wallet && (
          <div className="warning-message">
            <span className="warning-icon">‚ö†Ô∏è</span>
            <div>
              <h4>No Wallet Found</h4>
              <p>Please create or import a wallet to enable automated minting.</p>
            </div>
          </div>
        )}

        {!currentProvider && (
          <div className="warning-message">
            <span className="warning-icon">‚ö†Ô∏è</span>
            <div>
              <h4>Provider Not Available</h4>
              <p>Please check your network connection and RPC settings.</p>
            </div>
          </div>
        )}

        <div className="status-section success">
          <div className="status-icon">ü§ñ</div>
          <div>
            <h4>Automated Ladder Minting {wallet && currentProvider ? 'Ready' : 'Pending Setup'}</h4>
            <ul>
              <li>‚úÖ No MetaMask popups - Runs in background</li>
              <li>‚úÖ Creates {totalTransactions} XENFTs across {totalTerms} different terms</li>
              <li>{currentProvider ? '‚úÖ' : '‚è≥'} Uses {customRpc ? 'custom' : 'default'} RPC</li>
              <li>üéØ Network: {NETWORKS[selectedNetwork].name}</li>
              <li>üéØ Contract: {getCurrentContractAddress()}</li>
            </ul>
          </div>
        </div>

        <div className="launch-section">
          <button 
            onClick={handleStartMinting}
            disabled={!wallet || !currentProvider || isMinting || config.startTerm >= config.endTerm}
            className={`launch-button ${(!wallet || !currentProvider || isMinting || config.startTerm >= config.endTerm) ? 'disabled' : ''}`}
          >
            <span className="button-icon">
              {isMinting ? 'ü§ñ' : 'üìä'}
            </span>
            <span className="button-text">
              {isMinting ? 'Automated Minting in Progress...' : 'Start Automated Ladder Minting'}
            </span>
          </button>

          {!wallet && (
            <div className="launch-hint">
              <p>Need a wallet? Go to the Wallet tab to create or import one.</p>
            </div>
          )}

          {!currentProvider && (
            <div className="launch-hint">
              <p>Provider not available. Check your network connection.</p>
            </div>
          )}

          {config.startTerm >= config.endTerm && (
            <div className="validation-error">
              <p>‚ö†Ô∏è End term must be greater than start term</p>
            </div>
          )}
        </div>

        {/* Minting Progress */}
        {(isMinting || mintingLogs.length > 0) && (
          <MintingProgress 
            isMinting={isMinting}
            progress={mintingProgress}
            currentTransaction={currentTransaction}
            logs={mintingLogs}
            onStop={stopMinting}
            onPause={pauseMinting}
            onResume={resumeMinting}
            isPaused={isPaused}
          />
        )}
      </div>
    );
  };

const HelpTab = () => (
  <div className="tab-content">
    <div className="mode-header">
      <div className="mode-icon">üìö</div>
      <h3>How to Use MintXEN</h3>
      <p>Complete guide to automated XENFT batch minting</p>
    </div>

    <div className="help-section">
      {/* Quick Start Flow */}
      <div className="help-card featured">
        <div className="help-card-header">
          <div className="help-icon">üöÄ</div>
          <h4>Quick Start Guide</h4>
        </div>
        <div className="help-content">
          <div className="user-flow">
            <div className="flow-step">
              <div className="step-number">1</div>
              <div className="step-content">
                <h5>Import or Create Wallet</h5>
                <p>Go to the <strong>Wallet</strong> tab and either generate a new wallet or import your existing private key.</p>
              </div>
            </div>
            <div className="flow-arrow">‚Üì</div>
            
            <div className="flow-step">
              <div className="step-number">2</div>
              <div className="step-content">
                <h5>Fund Your Wallet</h5>
                <p>Add ETH to your wallet address for gas fees. You'll need ~$10-50 worth depending on network and batch size.</p>
              </div>
            </div>
            <div className="flow-arrow">‚Üì</div>
            
            <div className="flow-step">
              <div className="step-number">3</div>
              <div className="step-content">
                <h5>Choose Network & Configure</h5>
                <p>Select your network (Optimism for cheapest fees), then go to <strong>Rainbow</strong> or <strong>Ladder</strong> mode to set up your batch.</p>
              </div>
            </div>
            <div className="flow-arrow">‚Üì</div>
            
            <div className="flow-step">
              <div className="step-number">4</div>
              <div className="step-content">
                <h5>Start Automated Minting</h5>
                <p>Review your settings and click "Start Minting". Keep this tab open while transactions process automatically.</p>
              </div>
            </div>
            <div className="flow-arrow">‚Üì</div>
            
            <div className="flow-step">
              <div className="step-number">5</div>
              <div className="step-content">
                <h5>View Your XENFTs</h5>
                <p>After minting completes, visit <a href="https://xen.network/optimism/xenft/torrent" target="_blank" rel="noopener noreferrer" className="external-link">xen.network/xenft</a> to view and manage your newly minted XENFTs.</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Key Terms & Concepts */}
      <div className="help-card">
        <div className="help-card-header">
          <div className="help-icon">üéì</div>
          <h4>Key Terms Explained</h4>
        </div>
        <div className="help-content">
          <div className="terms-grid">
            <div className="term-item">
              <h5>üíé X E N F T</h5>
              <p>Non-fungible tokens that represent a bactch of XEN cRANKs . Why make one mint when you can make 128 ;D</p>
            </div>
            
            <div className="term-item">
              <h5>‚ö° VMU (Virtual Mining Units)</h5>
              <p>The "mining power" of your XENFT. Higher VMUs = higher power group = longer maturity time but more potential XEN rewards.</p>
            </div>
            
            <div className="term-item">
              <h5>üìÖ Term Length</h5>
              <p>How many days your XENFT will take to mature. Longer terms typically yield more XEN when burned.</p>
            </div>
            
            <div className="term-item">
              <h5>üé® Power Group</h5>
              <p>Classification system (0-7) based on VMUs √ó Term Length √∑ 7500. Higher power groups have different visual rarities.</p>
            </div>
            
            <div className="term-item">
              <h5>‚õΩ Gas Price</h5>
              <p>Fee paid to miners for processing your transaction. Higher = faster confirmation, lower = cheaper but slower.</p>
            </div>
            
            <div className="term-item">
              <h5>üîó RPC Endpoint</h5>
              <p>The server that connects your app to the blockchain. Default works fine, but custom ones can be faster.</p>
            </div>
          </div>
          
          <div className="help-tip">
            <strong>üí° Power Group Formula:</strong> Power Group = (VMUs √ó Term Length) √∑ 7500<br/>
            Example: 128 VMUs √ó 200 days = 25,600 √∑ 7500 = Power Group 3
          </div>
        </div>
      </div>

      {/* Network Selection */}
      <div className="help-card">
        <div className="help-card-header">
          <div className="help-icon">üåê</div>
          <h4>Choosing Your Network</h4>
        </div>
        <div className="help-content">
          <div className="network-comparison">
            <div className="network-option recommended">
              <h6>üöÄ Optimism (Recommended)</h6>
              <div className="network-stats">
                <span className="stat">‚õΩ Gas: ~$0.0001-0.001 per mint</span>
                <span className="stat">‚ö° Speed: 1-2 seconds</span>
                <span className="stat">üí∞ Best for: Large batches / Low gas</span>
              </div>
              <p>Cheapest option for minting. Perfect for rainbow mode or large ladder batches.</p>
            </div>
            
            <div className="network-option">
              <h6>üîó B a s e</h6>
              <div className="network-stats">
                <span className="stat">‚õΩ Gas: ~$0.30-2.50 per mint</span>
                <span className="stat">‚ö° Speed: 15-30 seconds</span>
                <span className="stat">üí∞ Best for: Hyper Inflation</span>
              </div>
              <p>Coinbase's L2 network. Good balance of cost and reliability.</p>
            </div>
            
            <div className="network-option expensive">
              <h6>‚ö†Ô∏è Ethereum Mainnet</h6>
              <div className="network-stats">
                <span className="stat">‚õΩ Gas: ~$5-100 per mint</span>
                <span className="stat">‚ö° Speed: 1-15 minutes</span>
                <span className="stat">üí∞ Best for: Single high-value mints</span>
              </div>
              <p>Most expensive but highest liquidity. Only use for special occasions or single mints.</p>
            </div>
          </div>
        </div>
      </div>

      {/* Rainbow vs Ladder Mode */}
      <div className="help-card">
        <div className="help-card-header">
          <div className="help-icon">üéØ</div>
          <h4>Rainbow vs Ladder Mode</h4>
        </div>
        <div className="help-content">
          <div className="mode-comparison">
            <div className="mode-option">
              <h5>üåà Rainbow Mode</h5>
              <div className="mode-features">
                <span className="feature">‚úÖ Creates all 8 power groups to create rainbow design in your portfoilo using the tokenID (0-7)</span>
                <span className="feature">‚úÖ Perfect for collectors</span>
                <span className="feature">‚úÖ Predictable cost for getting your feet wet (8 transactions)</span>
                <span className="feature">‚úÖ Great visual variety</span>
              </div>
              <p><strong>Best for:</strong> First-time users, collectors who want one of each power group, or anyone wanting maximum variety with minimal configuration.</p>
              <div className="example-config">
                <strong>Example:</strong> 128 VMUs ‚Üí Creates XENFTs ranging from 1 day (PG 0) to 274 days (PG 7)
              </div>
            </div>
            
            <div className="mode-option">
              <h5>üìä Ladder Mode</h5>
              <div className="mode-features">
                <span className="feature">‚úÖ Custom term ranges (e.g., 100-250 days)</span>
                <span className="feature">‚úÖ Multiple XENFTs per term</span>
                <span className="feature">‚úÖ Automate Laddering mints</span>
                <span className="feature">‚úÖ Scalable for large operations</span>
              </div>
              <p><strong>Best for:</strong> Advanced users who want specific term lengths, traders targeting particular power groups, or large-scale minting operations.</p>
              <div className="example-config">
                <strong>Example:</strong> Terms 150-200, 2 batches each ‚Üí Creates 102 XENFTs (51 terms √ó 2 each)
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Configuration Tips */}
      <div className="help-card">
        <div className="help-card-header">
          <div className="help-icon">‚öôÔ∏è</div>
          <h4>Configuration Best Practices</h4>
        </div>
        <div className="help-content">
          <div className="config-tips">
            <div className="tip-section">
              <h5>üí° VMU Selection</h5>
              <ul>
                <li><strong>128 VMUs:</strong> Good balance for most users (creates PG 0-7 in rainbow mode)</li>
                <li><strong>64 VMUs:</strong> Lower power groups, shorter terms, cheaper overall</li>
                <li><strong>256+ VMUs:</strong> Only on BASE due to their 140M gas limit</li>
              </ul>
            </div>
            
            <div className="tip-section">
              <h5>‚õΩ Gas Price Strategy</h5>
              <ul>
                <li><strong>Network normal:</strong> Use default (0.00003 gwei) for OP networks</li>
                <li><strong>Network congested:</strong> Increase by 20-50% for faster confirmation</li>
                <li><strong>Not urgent:</strong> Lower gas price to save money (transactions may take longer)</li>
              </ul>
            </div>
            
            <div className="tip-section">
              <h5>‚è±Ô∏è Timing & Delays</h5>
              <ul>
                <li><strong>5-10 seconds:</strong> Recommended delay between transactions</li>
                <li><strong>30 seconds:</strong> Minimum for most RPC providers</li>
                <li><strong>120+ seconds:</strong> Use for very large batches to avoid rate limiting</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      {/* Troubleshooting */}
      <div className="help-card">
        <div className="help-card-header">
          <div className="help-icon">üîß</div>
          <h4>Common Issues & Solutions</h4>
        </div>
        <div className="help-content">
          <div className="troubleshooting">
            <div className="issue">
              <h5>‚ùå "Insufficient funds" error</h5>
              <p><strong>Solution:</strong> Add more ETH to your wallet. Each transaction costs $0.10-50 depending on network and gas prices.</p>
            </div>
            
            <div className="issue">
              <h5>‚è≥ Transactions stuck/pending</h5>
              <p><strong>Solution:</strong> Increase gas price by 20% or wait for network congestion to clear. You can also restart with higher gas.</p>
            </div>
            
            <div className="issue">
              <h5>üîÑ "Nonce too low" error</h5>
              <p><strong>Solution:</strong> Wait 30 seconds and try again. This happens when transactions are sent too quickly.</p>
            </div>
            
            <div className="issue">
              <h5>üåê RPC connection issues</h5>
              <p><strong>Solution:</strong> Try a different RPC provider (Alchemy, Infura, Ankr) or check your internet connection.</p>
            </div>
            
            <div className="issue">
              <h5>üîë Lost private key</h5>
              <p><strong>Solution:</strong> Unfortunately, there's no recovery. Always backup your private key securely before starting.</p>
            </div>
          </div>
        </div>
      </div>

      {/* Security Best Practices */}
      <div className="help-card important">
        <div className="help-card-header">
          <div className="help-icon">üîí</div>
          <h4>Security & Safety</h4>
        </div>
        <div className="help-content">
          <div className="security-tips">
            <div className="security-section safe">
              <h5>‚úÖ Do This</h5>
              <ul>
                <li>Backup your private key before starting</li>
                <li>Start with small test batches first</li>
                <li>Use trusted RPC providers (Alchemy, Infura, Ankr)</li>
                <li>Keep this browser tab open during minting</li>
                <li>Double-check network and gas prices</li>
                <li>Import your key into MetaMask for permanent storage</li>
              </ul>
            </div>
            
            <div className="security-section danger">
              <h5>‚ùå Never Do This</h5>
              <ul>
                <li>Share your private key with anyone</li>
                <li>Use this on public/shared computers</li>
                <li>Close the browser tab while minting is active</li>
                <li>Use untrusted custom RPC endpoints</li>
                <li>Mint without backing up your private key first</li>
                <li>Enter your private key on suspicious websites</li>
              </ul>
            </div>
          </div>
          
          <div className="help-tip warning">
            <strong>‚ö†Ô∏è Important:</strong> Your private key is only stored in this browser session and will be deleted when you close the browser. Make sure to backup your key and import it into a proper wallet like MetaMask for long-term storage.
          </div>
        </div>
      </div>

      {/* After Minting */}
      <div className="help-card">
        <div className="help-card-header">
          <div className="help-icon">üéâ</div>
          <h4>After Minting: What's Next?</h4>
        </div>
        <div className="help-content">
          <div className="next-steps">
            <div className="step">
              <h5>1. üëÄ View Your XENFTs</h5>
              <p>Visit <a href="https://xen.network/optimism/xenft/torrent" target="_blank" rel="noopener noreferrer" className="external-link">xen.network/xenft</a> and connect your wallet to see your newly minted XENFTs.</p>
            </div>
            
            <div className="step">
              <h5>2. ‚è∞ Wait for Maturity</h5>
              <p>Your XENFTs will mature over time based on their term length. You can check maturity dates on the XEN website.</p>
            </div>
            
            <div className="step">
              <h5>3. üî• Burn for XEN</h5>
              <p>Once mature, you can burn your XENFTs to receive XEN tokens. Then you can burn them on https://burnxen.com - Longer terms typically yield more XEN.</p>
            </div>
            
            <div className="step">
              <h5>4. üí∞ Trade or Hold</h5>
              <p>You can also trade your XENFTs on NFT marketplaces like OpenSea, or hold them as collectibles.</p>
            </div>
          </div>
          
          <div className="help-tip">
            <strong>üéØ Pro Tip:</strong> Different power groups have different visual rarities and potential values. Higher power groups (5-7) are generally rarer and more sought after by collectors.
          </div>
        </div>
      </div>
    </div>
  </div>
);

  const PortfolioTab = () => (
    <div className="tab-content">
      <div className="mode-header">
        <div className="mode-icon">üëÅÔ∏è</div>
        <h3>Portfolio</h3>
        <p>View and manage your existing XENFTs across all networks</p>
      </div>

      <div className="coming-soon">
        <div className="coming-soon-icon">üöÄ</div>
        <h3>Multi-Chain Portfolio Coming Soon</h3>
        <p>Advanced portfolio viewer with cross-chain analytics, filtering, and detailed XENFT information across all supported networks.</p>
        
        <div className="feature-preview">
          <div className="feature-card">
            <div className="feature-icon">üåê</div>
            <h4>Multi-Chain View</h4>
            <p>See XENFTs across all networks</p>
          </div>
          <div className="feature-card">
            <div className="feature-icon">üìà</div>
            <h4>Cross-Chain Analytics</h4>
            <p>Combined performance metrics</p>
          </div>
          <div className="feature-card">
            <div className="feature-icon">üîç</div>
            <h4>Advanced Filtering</h4>
            <p>Filter by network, power group, status</p>
          </div>
        </div>
      </div>
    </div>
  );

  // Minting Progress Component
  const MintingProgress = ({ isMinting, progress, currentTransaction, logs, onStop, onPause, onResume, isPaused }) => {
    if (!isMinting && (!logs || logs.length === 0)) {
      return null;
    }

    const getLogIcon = (type) => {
      switch (type) {
        case 'success': return '‚úÖ';
        case 'error': return '‚ùå';
        case 'warning': return '‚ö†Ô∏è';
        default: return '‚ÑπÔ∏è';
      }
    };

    const getLogColor = (type) => {
      switch (type) {
        case 'success': return '#10b981';
        case 'error': return '#ef4444';
        case 'warning': return '#eab308';
        default: return '#3b82f6';
      }
    };

    return (
      <div className="minting-progress">
        <div className="progress-header">
          <h4>‚ö° Minting Progress {isPaused && <span className="paused-badge">Paused</span>}</h4>
          {isMinting && (
            <div className="progress-controls">
              {onPause && onResume && (
                <button onClick={isPaused ? onResume : onPause} className="btn-control">
                  {isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause'}
                </button>
              )}
              <button onClick={onStop} className="btn-control stop">
                ‚ùå Stop
              </button>
            </div>
          )}
        </div>
        
        {isMinting && (
          <div className="progress-bar-section">
            <div className="progress-info">
              <span>Overall Progress</span>
              <span>{Math.round(progress)}%</span>
            </div>
            <div className="progress-bar">
              <div 
                className="progress-fill"
                style={{ width: `${progress}%` }}
              />
            </div>
          </div>
        )}
        
        {currentTransaction && (
          <div className="current-transaction">
            <div className="transaction-header">
              <span className="transaction-count">Transaction {currentTransaction.index}/{currentTransaction.total}</span>
              <div className="transaction-status">
                <div className={`status-indicator ${isPaused ? 'paused' : 'processing'}`} />
                <span>{isPaused ? 'Paused' : 'Processing...'}</span>
              </div>
            </div>
            
            <div className="transaction-details">
              {currentTransaction.group && (
                <>
                  <div className="detail-row">
                    <span>Power Group:</span>
                    <span>{currentTransaction.group}</span>
                  </div>
                  <div className="detail-row">
                    <span>Term Length:</span>
                    <span>{currentTransaction.term} days</span>
                  </div>
                </>
              )}
              
              {currentTransaction.batch && (
                <>
                  <div className="detail-row">
                    <span>Term:</span>
                    <span>{currentTransaction.term} days</span>
                  </div>
                  <div className="detail-row">
                    <span>Batch:</span>
                    <span>{currentTransaction.batch}/{currentTransaction.batches}</span>
                  </div>
                </>
              )}
              
              <div className="detail-row">
                <span>VMUs:</span>
                <span>{currentTransaction.vmu || 'N/A'}</span>
              </div>
            </div>
          </div>
        )}

        {logs && logs.length > 0 && (
          <div className="logs-section">
            <h5>Transaction Log</h5>
            <div className="logs-container">
              {logs.slice().reverse().map((log, index) => (
                <div key={index} className="log-entry">
                  <div className="log-header">
                    <span className="log-icon">{getLogIcon(log.type)}</span>
                    <span className="log-timestamp">{log.timestamp}</span>
                    <span className="log-type" style={{ color: getLogColor(log.type) }}>
                      {log.type}
                    </span>
                  </div>
                  <p className="log-message" style={{ color: getLogColor(log.type) }}>
                    {log.message}
                  </p>
                </div>
              ))}
            </div>
          </div>
        )}

        {!isMinting && logs && logs.length > 0 && (
          <div className="session-summary">
            <h5>Session Summary</h5>
            <div className="summary-stats">
              <div className="stat">
                <div className="stat-value success">{logs.filter(log => log.type === 'success').length}</div>
                <div className="stat-label">Successful</div>
              </div>
              <div className="stat">
                <div className="stat-value error">{logs.filter(log => log.type === 'error').length}</div>
                <div className="stat-label">Failed</div>
              </div>
              <div className="stat">
                <div className="stat-value warning">{logs.filter(log => log.type === 'warning').length}</div>
                <div className="stat-label">Warnings</div>
              </div>
              <div className="stat">
                <div className="stat-value info">{logs.length}</div>
                <div className="stat-label">Total Logs</div>
              </div>
            </div>
          </div>
        )}

        {isMinting && (
          <div className="minting-instructions">
            <div className="instruction-icon">‚ÑπÔ∏è</div>
            <div>
              <p><strong>Minting in Progress</strong></p>
              <ul>
                <li>‚Ä¢ Do not close this browser tab</li>
                <li>‚Ä¢ Transactions are executed with delays between them</li>
                <li>‚Ä¢ You can pause or stop the process at any time</li>
                <li>‚Ä¢ Stop button will halt after current transaction completes</li>
                <li>‚Ä¢ Using {NETWORKS[selectedNetwork].name} network</li>
              </ul>
            </div>
          </div>
        )}
      </div>
    );
  };

  // Main render
  return (
    <div className="app">
      {!showApp ? (
        // Hero Landing Page
        <div className="hero-landing">
          <div className="hero-content">
            <div className="hero-header">
              <h1 className="hero-title">MintXEN</h1>
              <p className="hero-subtitle">Multi-Chain XENFT Minting</p>
            </div>
            
            <div className="hero-features">
              <div className="hero-feature">
                <span className="feature-emoji">üõ°Ô∏è</span>
                <span className="feature-text">Your keys, your XENFTs</span>
              </div>
              <div className="hero-feature">
                <span className="feature-emoji">ü§ñ</span>
                <span className="feature-text">Automated batch minting</span>
              </div>
              <div className="hero-feature">
                <span className="feature-emoji">üåê</span>
                <span className="feature-text">Multi-chain support</span>
              </div>
            </div>
            
            <button 
              onClick={() => setShowApp(true)}
              className="hero-launch-button"
            >
              <span className="launch-icon">üöÄ</span>
              Launch App
            </button>

            <div className="hero-modes">
              <div className="hero-mode-card">
                <div className="mode-emoji">üåà</div>
                <h3>Rainbow Mode</h3>
                <p>Create XENFTs across all power groups for colorway variety</p>
              </div>
              <div className="hero-mode-card">
                <div className="mode-emoji">üìä</div>
                <h3>Ladder Mode</h3>
                <p>Custom term ranges with precise control over minting</p>
              </div>
              <div className="hero-mode-card">
                <div className="mode-emoji">üåê</div>
                <h3>Multi-Chain</h3>
                <p>Support for Optimism, Ethereum, and Base networks</p>
              </div>
            </div>
          </div>
        </div>
      ) : (
        // Main App Interface
        <div className="app-interface">
          {/* Header */}
          <header className="app-header">
            <div className="header-content">
              <div className="header-left">
                <button 
                  onClick={() => setShowApp(false)}
                  className="back-to-home"
                >
                  ‚Üê Back to Home
                </button>
                <h1>MintXEN</h1>
                {networkInfo && (
                  <div className="network-status">
                    <div className="network-indicator" />
                    <span>{networkInfo.name === 'unknown' ? `Chain ${networkInfo.chainId}` : networkInfo.name}</span>
                  </div>
                )}
              </div>

              <div className="header-center">
                <NetworkSelector />
              </div>

              <div className="header-right">
                {isConnectedToMetaMask ? (
                  <div className="wallet-status">
                    <div className="wallet-info">
                      <div className="wallet-label">Connected</div>
                      <div className="wallet-address">
                        {connectedAddress?.slice(0, 6)}...{connectedAddress?.slice(-4)}
                      </div>
                    </div>
                    <button onClick={disconnectBlockchain} className="btn-disconnect">
                      Disconnect
                    </button>
                  </div>
                ) : (
                  <button
                    onClick={() => connectToBlockchain()}
                    disabled={isConnecting}
                    className="btn-connect"
                  >
                    {isConnecting ? (
                      <>
                        <div className="spinner" />
                        Connecting...
                      </>
                    ) : (
                      <>ü¶ä Connect Wallet</>
                    )}
                  </button>
                )}
              </div>
            </div>
          </header>

          {/* Main Content */}
          <main className="main-content">
            <div className="container">
              {/* Tab Navigation */}
              <div className="tab-navigation">
                <button
                  onClick={() => setActiveTab('wallet')}
                  className={`tab-button ${activeTab === 'wallet' ? 'active' : ''}`}
                >
                  üîë Wallet
                </button>
                <button
                  onClick={() => setActiveTab('rainbow')}
                  className={`tab-button ${activeTab === 'rainbow' ? 'active' : ''}`}
                  disabled={!wallet || walletStep !== 'complete'}
                >
                  üåà Rainbow
                </button>
                <button
                  onClick={() => setActiveTab('ladder')}
                  className={`tab-button ${activeTab === 'ladder' ? 'active' : ''}`}
                  disabled={!wallet || walletStep !== 'complete'}
                >
                  üìä Ladder
                </button>
                <button
                  onClick={() => setActiveTab('portfolio')}
                  className={`tab-button ${activeTab === 'portfolio' ? 'active' : ''}`}
                  disabled={!wallet || walletStep !== 'complete'}
                >
                  üëÅÔ∏è Portfolio
                </button>
                <button
                  onClick={() => setActiveTab('help')}
                  className={`tab-button ${activeTab === 'help' ? 'active' : ''}`}
                >
                  üìö Help
                </button>
              </div>

              {/* Tab Content */}
              <div className="tab-panel">
                {activeTab === 'wallet' && <WalletTab />}
                {activeTab === 'rainbow' && <RainbowTab />}
                {activeTab === 'ladder' && <LadderTab />}
                {activeTab === 'portfolio' && <PortfolioTab />}
                {activeTab === 'help' && <HelpTab />}
              </div>
            </div>
          </main>

          {/* Footer */}
          <footer className="app-footer">
            <p>Built for the XEN community ‚Ä¢ Multi-chain XENFT minting ‚Ä¢ Your keys, your XENFTs</p>
          </footer>
        </div>
      )}
    </div>
  );
};

export default App;